<?php

use App\Block;
use App\Category;
use App\Course;
use App\Lesson;
use Illuminate\Database\Seeder;
//use CoursesCreate;


class CoursesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $categories = ['Математика', 'Программирование', 'Экономика'];
        foreach ($categories as $c) {
            Category::create([
                'name' => $c
            ]);
        }
        $course = Course::Create([
            'name' => 'Дифференциальные уравнения',
            'description' => 'Очень важный курс для настоящих героев!',
            'image' => 'diff_eq.jpeg',
            'category_id' => 1,
            'active' => true,
            'user_id' => 1
        ]);


        $names = ['Уравнения первого порядка', 'Линейные уравнения n-го порядка'];
        $blocks = [];

        foreach ($names as $k => $n) {
            $blocks[] = Block::Create([
                'course_id' => $course->id,
                'name' => $n,
                'active' => true,
                'sort' => $k
            ]);
        }

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Основные понятия и определения',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => '**Дифференциальным уравнением** называется уравнение, связывающее независимую переменную х, искомую функцию y = y (x) и ее производные $y... y^{(n)}$, т.е. уравнения вида $F(x,y,y,y,...,y^{(n)}$)

Дифференциальное уравнение называется **обыкновенным**, если искомая функция y имеет вид y = y(x) (т.е функция одной независимой переменной)

**Порядком** дифференциального уравнения называется порядок наивысшей производной, входящей в уравнение

**Решением** дифференциального уравнения n-го порядка на интервале (a, b) называется функция $y=\gamma(x)$, определенная на (a, b) вместе со своими производными до n-го порядка включительно, и такая что ее подстановка в дифференциальное уравнение, превращает его в тождество по x на (a, b).

График решения дифференциального уравнения называется **интегральной кривой** этого уравнения.

### Формы задания

* Общий вид: $f(x,y,y)=0$
* Нормальный вид: $y=f(x,y)$
* Дифференциальная форма: $M(x,y)dx+N(x,y)dy=0$
* Симметрическая форма: $\frac{dx}{X(x,y)}=\frac{dy}{Y(x,y)}$

### Виды записи решения

* Нормальная форма: $y=\gamma(x)$
* Неявная форма: $F(x,y)=0$
* Параметрическая форма: $\begin{cases}
   x=\beta(t)\\\
   y=\alpha(t)
\end{cases}$, $x\in(a,b), t\in(\omega,\eta), a=\beta(\omega), b=\alpha(\eta)$
',
            'video' => 'hello.mov'
        ]);

        $questions = [
            [
                'q' => 'Что называется обыкновенным дифференциальным уравнением n –го порядка?',
                'a' => [
                    'Соотношение, связывающее независимую переменную, неизвестную функцию и все ее производные до n-го порядка включительно.',
                    'Соотношение, связывающее неизвестную переменную, независимую переменную и все ее производные до n-го порядка включительно.',
                    'Дифференциальное уравнеие n-ой степени.',
                    'Уравнение, содержащее n независимых переменных.',
                ],
                'c' => [true, false, false, false]
            ],
            [
                'q' => 'Как называется процесс решения дифференциального уравнения?',
                'a' => [
                    'Дифференцирование',
                    'Интегрирование',
                    'Построение',
                    'Отождествление'
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Что называется порядком дифференциального уравнения?',
                'a' => [
                    'Колличество производных, входящих в уравнение',
                    'Колличество независимых переменных, входящих в уравнение',
                    'Наивысшая степень производной, входящей в уравнение',
                    'Наивысший порядок производной, входящей в уравнение'
                ],
                'c' => [false, false, false, true]
            ]
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Задача Коши',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Задачей Коши называют задачу нахождения решения решения $y=y(x)$ уравнения $y\'=f(x,y)$, удовлетворяющего начальному условию $y(x_0)=y_0$

Геометрически: ищем интегральную кривую, проходящую через заданную точку $M_0$ плоскости $xOy$

**Теорема существования и единственности решения задачи Коши.** Пусть дано дифференциальное уравнение $y\'=f(x,y)$, где функция f(x,y) определена в некоторой области D плоскости $xOy$, содержащей точку $(x_0,y_0)$. Если функция f(x,y) удовлетворяет условиям
* $f(x,y)$ есть непрерывная функция двух переменных x и y в области D
* $f(x,y)$ имеет частную производную $\frac{\partial{f}}{\partial{y}}$, ограниченную в области D

то найдется интервал $(x_0-h,x_0+h)$, на котором существует единственное решение $y=\gamma(x)$ данного уравнения, удовлетворяющее условию $y(x_0)=y_0$
',
            //'video' => 'defs.mp4'
        ]);

        $questions = [
            [
                'q' => 'Выберите условия теоремы существования и единственности решения задачи Коши для функции f(x,y), определенной в области D',
                'a' => [
                    'f(x, y) непрерывна в области D',
                    'f(x, y) ограничена в области D',
                    'f(x, y) монотонно возрастает в области D',
                    'f(x, y) имеет частную производную по y, ограниченную в области D'
                ],
                'c' => [true, false, false, true]
            ],
            [
                'q' => 'Сколько решений может иметь задача Коши если функция f(x,y) непрерывна и удовлетворяет условию Липшица?',
                'a' => [
                    '0',
                    '1',
                    'Число, равное степени f(x,y)',
                    'Число, равное порядку уравнения'
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Какая геометрическая интерпретация задачи Коши?',
                'a' => [
                    'Нахождение наименьшего радиуса окружности с центром в точке (x0, y0) и касающейся одной из интегральных кривых',
                    'Нахождение изоклины, проходящей через заданную точку ($x_0,y_0$)',
                    'Нахождение интегральной кривой, проходящей через заданную точку ($x_0,y_0$)',
                ],
                'c' => [false, false, true]
            ]
        ];
        $this->create_questions($lesson, $questions);

        //linear equasions
        $lesson = Lesson::Create([
            'block_id' => $blocks[1]->id,
            'active' => true,
            'name' => 'Основные понятия и определения',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Уравнение вида $a_0(x)y^{(n)}+a_1(x)y^{(n-1)}+..+a_{n-1}(x)y\'+a_n(x)y=\gamma(x)$ (*), где $a_1(x)..a_n(x), \gamma(x)$  непрерывные на (a,b) функции  называют линейным дифференциальным уравнением n-го порядка.

$\forall{x_0\in{(a,b)}}, \forall{y_0..y_{n-1}}\space\exists!$ решение  следующей задачи Коши:

$\begin{cases}
   a_o(x)y^{(n)}+a_1(x)y^{(n-1)}+..+a_{n-1}(x)y\'+a_n(x)y=\gamma(x) \\\
   y(x_0)=y_0 \\\
   y\'(x_0)=y_1 \\\
   : \\\
   y^{(n-1)}(x_0)=y_{n-1}
\end{cases}$

Приведем уравнение (*) к каноническому виду, для этого поделим обе его части на $a_0(x)$, получим:

$y^{(n)}+p_1(x)y^{(n-1)}+..+p_n(x)y=f(x), p_i(x)=\frac{a_i(x)}{a_0(x)}, f(x)=\frac{\gamma(x)}{a_0(x)}$ (1)

Пусть $L$ - линейный оператор, определяемый формулой:

$L(y)=y^{(n)}+p_1(x)y^{(n-1)}+..+p_n(x)y$

тогда уравнение (1) можно записать в виде:

$L[y]=f(x)$

Если $f(x)\equiv{0}$, то получим однородное уравнение:

$L[y]=0$ (2)

#### Свойства линейного оператора L.

1) $L[Cy]=CL[y]$, C - const
2) $L[y_1+y_2]=L[y_1]+L[y_2]$

#### Свойства линейного дифференциального уравнения.

1) Уравнение остается линейным при любой замене независимой переменной x.

2) Уравнение остается линейным при линейной замене неизвестной функции $y$, т.е. $y=a(x)z(x)+b(x)$, где $a(x),b(x),z(x)$ - непрерывно дифференцируемые n раз функции.

#### Свойства решений линейного однородного дифференциального уравнения (2)

1) Если y=y(x) - решение уравнения (2), то функция $y_1(x)=Cy(x)$, C - const, также решение уравнения (2).

2) Если $y_1(x)$ и $y_2(x)$ решения уравнения (2), то $y_1(x)+y_2(x)$, также решение уравнения (2).

3) Если $y_1(x)..y_n(x)$ - решения уравнения (2), то функция $y=C_1y_1(x)+..+C_ny_n(x)$, также решение уравнения (2).

',
            //'video' => 'defs.mp4'
        ]);

        $questions = [
            [
                'q' => 'Сколько особых решений может иметь линейное дифференциальное уравнение n-го порядка?',
                'a' => [
                    '1',
                    '0',
                    '2',
                    'Это определяется в зависимости от уравнения',
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'При какой замене независимой переменной x линейное дифференциальное уравнение n-го порядка останется линейным?',
                'a' => [
                    'При линейной',
                    'При замене на константу',
                    'При любой замене',
                    'Таких замен не существует',
                ],
                'c' => [true, true, true, false]
            ],
            [
                'q' => 'При какой замене неизвестной функции y линейное дифференциальное уравнение n-го порядка останется линейным?',
                'a' => [
                    'При линейной',
                    'При замене на константу',
                    'При любой замене',
                    'Таких замен не существует',
                ],
                'c' => [true, false, false, false]
            ],
            [
                'q' => 'Если $y(x)$ - решение линейного однородного дифференциального уравнения $L[y]=0$, то какие еще функции точно будут его решениями',
                'a' => [
                    '$y=y^2(x)$',
                    '$y=Cy(x)$, C - const',
                    '$y=t(x)y(x), t(x)$ - линейная функция',
                    '$y=\frac{1}{y(x)}$',
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Если $y_1(x),y_2(x)$ - решения линейного однородного дифференциального уравнения $L[y]=0$, то какие еще функции точно будут его решениями',
                'a' => [
                    '$y=y_1(x)+y_2(x)$',
                    '$y=y_1(x)-y_2(x)$',
                    '$y=C_1y_1(x)+C_2y_2(x),C_1,C_2$ - const',
                    '$y=\frac{y_1(x)}{y_2(x)}$',
                    '$y=y_1(x)y_2(x)$',
                ],
                'c' => [true, true, true, false,false]
            ],
            [
                'q' => 'Сколько решений задачи Коши $y(x_0)=y_0,y\'(x_0)=y\'_0,..,y^{(n-1)}(x_0)=y^{(n-1)}_0$ имеет линейное дифференциальное уравнение n-го порядка',
                'a' => [
                    '1',
                    '2',
                    '0',
                    'много',
                ],
                'c' => [true, false, false, false]
            ]
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[1]->id,
            'active' => true,
            'name' => 'Понятие линейной независимости функций',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Функции $y_1(x)..y_n(x), x\in(a,b)$ называются линейно независимыми, если равенство $\alpha_1y_1(x)+..+\alpha_ny_n(x)=0$ справедливо только в случае, когда $\alpha_1=..=\alpha_n=0, \alpha_i-const, i=\overline{1,n}$, в противном случае функции $y_1(x)..y_n(x)$ называются линейно зависимыми.

Функции $y_1(x)..y_n(x), x\in(a,b)$ называются линейно зависимыми, если $\exists\space\alpha_1..\alpha_n$, не все равные нулю и такие что равество $\alpha_1y_1(x)+..+\alpha_ny_n(x)=0$ справедливо.

Пусть функции $y_1(x)..y_n(x)$ имеют производные до n-го порядка включительно, тогда определитель вида

$W(y_1..y_n)=W(x)=\begin{vmatrix}
   y_1(x) & y_2(x) & .. & y_n(x) \\\
   y_1\'(x) & y_2\'(x) & .. & y_n\'(x) \\\
   : & : & : & : \\\
   y_1^{(n-1)}(x) & y_2^{(n-1)}(x) & .. & y_n^{(n-1)}(x)
\end{vmatrix}$

называется определителем Вронского.

**Теорема.** Если функции $y_1..y_n$ линейно зависимы в интервале $(a,b)$, то $W(y_1..y_n)=0\space\forall{x\in{(a,b)}}$.

*Доказательство:*

**Теорема.** Если $y_1(x)..y_n(x)$ - линейно независимые решения уравнения $L[y]=0$, то  $W(y_1..y_n)\not=0\space\forall{x\in{(a,b)}}$.

*Доказательство:*

**Теорема.** Пусть $y_1(x)..y_n(x)$ - решения уравнения $L[y]=0$, тогда либо $W(y_1..y_n)=0$, либо $W(y_1..y_n)\not=0$, ни в одной точке интервала непрерывности коэффициентов уравнения.

**Фундаментальной системой (ФСР)** линейного однородного дифференциального уравнения n-го порядка называется система n линейно независимых решений этого уравнения.

**Теорема.** ФСР существует для любого линейного дифференциального уравнения.

Все решения линейного однородного уравнения n-го порядка образуют линейное пространство, базисом которого является любая ФСР этого уравнения.

**Теорема.** Если $y_1..y_n$ - ФСР уравнения $L[y]=0$, то его общее решение $C_1y_1+..+C_ny_n, C_1..C_n-const$.

**Теорема.** Всякие $n+1$ решений уравнения $L[y]=0$ линейно зависимы.',
            'examples' => '1) Исследовать являются ли функции $1, \sin(2x), (\sin(x)-\cos(x))^2$ линейно независимыми.

Данные функции определены $\forall{x\in{(-\infty, +\infty)}}$.

Если данная система линейно зависима то найдутся такие $a_1,a_2,a_3$, не все равные нулю, что для всех $x$ выполняется тождество $a_1+a_2\sin(2x)+a_3(\sin(x)-\cos(x))^2=0$ (1).

Упростим выражение, раскрыв скобки и приведя подобные слагаемые (1), получим:

$a_1-a_2sin(2x)+a_3=0$ или $\sin(2x)=\frac{a_1+a_3}{a_2}$

Для любых $x$, можно подобрать такие значения $a_1, a_2, a_3$, чтобы последнее равенство обращалось в верное тождество, значит функции $1, \sin(2x), (\sin(x)-\cos(x))^2$ линейно зависимы.

2) Найти определитель Вронского для системы функций $y_1=\pi,y_2=\arcsin(x),y_3=\arccos(x)$

$W[y_1,y_2,y_3]=\begin{vmatrix}
   \pi & \arcsin(x) & \arccos(x) \\\
   0 & (1-x^2)^{-\frac{1}{2}} & -(1-x^2)^{-\frac{1}{2}} \\\
   0 & x{(1-x^2)^{-\frac{3}{2}}} & -x{(1-x^2)^{-\frac{3}{2}}}
\end{vmatrix}=\pi{*}(-x(1-x^2)^{-2}+x(1-x^2)^{-2})=\pi{*0}=0$

Можем сделать вывод что данная система функций линейно зависима.
'
        ]);

        $questions = [
            [
                'q' => 'Чему равен определитель Вронского функций $y_1(x)..y_n(x)$ для $x\in{(a,b)}$, если они линейно зависимы в $(a,b)$?',
                'a' => [
                    'Все зависит от функций',
                    '0',
                    '1',
                    '$\infty$',
                    '$\frac{a+b}{2}$',
                ],
                'c' => [false, true, false, false, false]
            ],
            [
                'q' => 'Может ли определитель Вронского ФСР линейного однородного дифференциального уравнения обратиться в ноль в какой-нибудь точке задания уравнения?',
                'a' => [
                    'Да',
                    'Нет'
                ],
                'c' => [false, true]
            ],
            [
                'q' => 'Какой вид имеет общее решение однородного дифференциального уравнения, если $y_1..y_n$ - его ФСР?',
                'a' => [
                    '$y_1+..+y_n$',
                    '$C_1y_1+..+C_ny_n, C_i-const, i=\overline{1,n}$',
                    '$y_1+..+y_n+y_r, y_r-$ частное решение',
                    'Здесь нет правильного ответа',
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Если  $y_1..y_n,y_{n+1}$ - решения линейного однородного дифференциального уравнения, то какие выводы можно сделать?',
                'a' => [
                    'Одно из данных решений является линейной комбинацией других',
                    'Эти решения линейно независимы',
                    'Эти решения линейно зависимы',
                    '$y_1..y_n$ составляют ФСР',
                    'Каждое из данных решений можно получить линейной комбинацией других',
                ],
                'c' => [true, false, true, false, true]
            ],
            [
                'q' => '',
                'a' => [
                    '',
                    '',
                    '',
                    '',
                ],
                'c' => [true, false, false, false]
            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[1]->id,
            'active' => true,
            'name' => 'Дифференциальные уравнения, допускающие понижение порядка',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Опишем некоторые виды дифференциальных уравнений, допускающих понижение порядка.

1) Уравнение вида $y^{(n)}=f(x)$. Проинтегрировав n раз получим общее решение

$y=\underbrace{\int..\int}_{\text{n}}f(x)\underbrace{dx..dx}_{\text{n}}+C_1\frac{x^{n-1}}{(n-1)!}+C_2\frac{x^{n-2}}{(n-2)!}+..+C_{n-1}x+C_n$.

2) Уравнение, не содержащее искомой функции и ее производных до порядка $k-1$ включительно.

->$F(x,y^{(k)},y^{(k+1)},..,y^{(n)}(x))=0$<-

Сделаем замену $y^{(k)}(x)=p(x)$, тогда

->$F(x, p(x),p\'(x),..,p^{(n-k)}(x))=0$<-

Далее, по возможности, определяем $p=f(x,C_1,C_2,..,C_{n-k})$, потом $k-$кратным интегрированием находим $y$ из уравнения $y^{(k)}=p$.

3) Уравнение не содержит независимой переменной.

->$F(y,y\',..,y^{(n)})=0$<-

Сделаем замену $y\'=p(y)$ и выразим все производные уравнения через $p$.

->$\begin{aligned}
	&y\'=\frac{dy}{dx}=p\\\
  &y\'\'=\frac{dp}{dx}=\frac{dp}{dy}\frac{dy}{dx}=p\frac{dp}{dy}\\\
  &y\'\'\'=\frac{d}{dx}(p\frac{dp}{dy})=\frac{d}{dy}p\frac{dp}{dy}\frac{dy}{dx}=p^2\frac{d^2p}{dy^2}+p(\frac{dp}{dy})^2\\\
  &...
\end{aligned}$<-

Получим уравнение $(n-1)$-го порядка.
Будем продолжать процесс, пока это возможно.

4) Уравнение $F(x,y,y\',..,y^{(n)})=0$, однородное относительно аргументов $y,y\',..,y^{(n)}$, т.е.

->$F(x,ty,ty\',..,ty^{(n)})=t^kF(x,y,y\',..,y^{(n)})$<-

Сделаем замену $y=e^{\int{zdx}}$, где $z$ - новая неизвестная функция $z=z(x)$

5) Уравнение, записанное в дифференциалах 

->$F(x,y,dx,dy,d^2y,..,d^{(n)}y)=0$<-

В котором $F$ однородна относительно аргументов $x,y,dx.dyd^2y,..,d^{(n)}y$.

Если считать $x,dx$ первого измерения, $y,dy,d^2(y),..$ измерения $m$. Тогда $\frac{dy}{dx}$ будет иметь измерение $m-1$, $\frac{d^2y}{dx^2}$ - измерение $m-2$ и так далее.

Для понижения порядка применяется подстановка $x=e^t,\space{}y=ue^{mt}$. Так получается дифференциальное уравнение между $u$ и $t$, не содержащее явно $t$, то есть допускающее понижение порядка.',
            'examples' => ''
        ]);

        $questions = [
            [
                'q' => '',
                'a' => [
                    '',
                    '',
                    '',
                    '',
                ],
                'c' => [true, false, false, false]
            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[1]->id,
            'active' => true,
            'name' => 'Решение линейных дифференциальных уравнений.',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => '### Линейные однородные уравнения с постоянными коэффициентами.

Рассмотрим дифференциальное уравнение $a_0y^{(n)}+a_1y^{(n-1)}+..+a_n=0$ (1), где $a_0..a_n\in{R}, a_0\not=0$

Будем искать общее решение уравнения (1)

Составим характеристическое уравнение для уравнения (1):

$a_0\lambda^n+a_1\lambda^{n-1}+...+a_{n-1}\lambda+a_n=0$ (2)

Пусть $\lambda_1..\lambda_n$ - корни уравнения (2), тогда рассмотрим виды общего решения $y_0$ уравнения (2) в зависимости от их значений

1) $\lambda_1..\lambda_n$ вещественные и различные, тогда

ФСР={ $e^{\lambda_1x},e^{\lambda_2x},...e^{\lambda_nx}$ }

$y_0=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}+...+C_ne^{\lambda_nx}$

2) $\lambda_1..\lambda_n$ вещественные, но среди них имеются кратные.

Пусть $\lambda_1=\lambda_2=...=\lambda_k=\tilde{\lambda}$ - k-кратные решения уравнения (1), а все остальные n-k корней различные, тогда
ФСР={ $e^{\tilde{\lambda}x},xe^{\tilde{\lambda}x},x^2e^{\tilde{\lambda}x},..,x^{k-1}e^{\tilde{\lambda}x},e^{\lambda_{k+1}x},..,e^{\lambda_nx}$ }

$y_0=(C_1+xC_2+x^2C_3+..+x^{k-1}C_{k-1})e^{\tilde{\lambda}x}+C_{k+1}e^{\lambda_{k+1}x}+..+C_ne^{\lambda_nx}$

3) Среди $\lambda_1..\lambda_n$ есть комплексные.

Пусть например $\lambda_1=\alpha+i\beta, \lambda_2=\alpha-i\beta, \lambda_3=\gamma+i\delta, \lambda_4=\gamma-i\delta$, а остальные $n-4$ корней вещественные, тогда

ФСР={ $e^{\alpha{x}}cos(\beta{x}),e^{\alpha{x}}sin(\beta{x}),e^{\gamma{x}}cos(\delta{x}),e^{\gamma{x}}sin(\delta{x}),e^{\lambda_5x},..,e^{\lambda_nx}$ }

$y_0=e^{\alpha{x}}(C_1cos(\beta{x})+C_2sin(\beta{x}))+e^{\gamma{x}}(C_3cos(\delta{x})+C_4sin(\delta{x}))+C_5e^{\lambda_5x}+..+C_ne^{\lambda_nx}$

4) Среди $\lambda_1..\lambda_n$ имеются кратные комплексные корни

Пусть например $\lambda_1=\alpha+i\beta$ - k-кратный корень, тогда $\lambda_2=\alpha-i\beta$, также будет k-кратным корнем и тогда

ФСР={ $e^{\alpha{x}}cos(\beta{x}),e^{\alpha{x}}sin(\beta{x}),xe^{\alpha{x}}cos(\beta{x}),xe^{\alpha{x}}sin(\beta{x}),..,x^{k-1}e^{\alpha{x}}cos(\beta{x}),x^{k-1}e^{\alpha{x}}sin(\beta{x}),e^{\lambda_{2k+1}x},..,e^{\lambda_nx}$ }

$y_0=e^{\alpha{x}}(C_1+C_3x+C_5x^2+..+C_{k-1}x^{k-1})cos(\beta{x})+e^{\alpha{x}}(C_2+C_4x+C_6x^{k+2}+..+C_{2k}x^{2k})sin(\beta{x})+e^{\lambda_{2k+1}x}+..+e^{\lambda_nx}$

### Линейные неоднородные дифференциальные уравнения с постоянными коэффициентами

Рассмотрим дифференциальное уравнение $a_0y^{(n)}+a_1y^{(n-1)}+..+a_n=f(x)$ (3), где $a_0..a_n\in{R}, a_0\not=0$

**Теорема.** Общее решение неоднородного уравнения (3) равно сумме общего решения соответствующего однородного уравнения и какого-либо частного решения неоднородного уравнения.

Рассмотрим некоторые способы нахождения частного решения неоднородного уравнения.

1) Метод подбора.

Если правая часть уравнения (3) имеет вид
->$f(x)=e^{\alpha{x}}(P_l(x)cos(\beta{x})+Q_m(x)sin(\beta{x}))$,<-
где $P_l(x)$ и $Q_m(x)$ - многочлены степени l и m соответственно, то можно искать частное решение уравнения (3) в виде:

->$y_1(x)=x^se^{\alpha{x}}(\tilde{P_k}(x)cos(\beta{x})+\tilde{Q_k}(x)sin(\beta{x}))$,<-
где $k=max(m,l), \tilde{P_k}(x),\tilde{Q_k}(x)$ - многочлены от x k-й степени, а s-кратность корня $\lambda=\alpha+i\beta$ характеристического уравнения.

Покажем на схемах как действовать в некоторых случаях.
Вид схемы: $\boxed{\text{вид правой части}}\longrightarrow\begin{cases}
   \text{решение, если нет указанных корней соответствующего однородного уравнения}   \\\
   \text{решение, если есть указанные корни соответствующего однородного уравнения}
\end{cases}$

$\boxed{P_m(x)}\longrightarrow\begin{cases}
   \tilde{P_m}(x) &\text{если 0 не корень }   \\\
   x^s\tilde{P_m}(x) &\text{если 0 корень }
\end{cases}$

$\boxed{P_m(x)e^{\alpha{x}}}\longrightarrow\begin{cases}
   \tilde{P_m}(x)e^{\alpha{x}} &\text{если}\space\alpha\space\text{не корень }   \\\
   x^s\tilde{P_m}(x)e^{\alpha{x}} &\text{если}\space\alpha\space\text{корень }
\end{cases}$

$\boxed{P_n(x)cos(\beta{x})+Q_m(x)sin(\beta{x})}\longrightarrow\begin{cases}
   \tilde{P_k}(x)cos(\beta{x})+\tilde{Q_k}(x)sin(\beta{x}),k=max(m,n) &\text{если}\space\mp{i\beta}\space\text{не корни }   \\\
   x^s(\tilde{P_k}(x)cos(\beta{x})+\tilde{Q_k}(x)sin(\beta{x})),k=max(m,n) &\text{если}\space\mp{i\beta}\space\text{корни }
\end{cases}$

$\boxed{e^{\alpha{x}}(P_n(x)cos(\beta{x})+Q_m(x)sin(\beta{x}))}\longrightarrow\begin{cases}
   e^{\alpha{x}}(\tilde{P_k}(x)cos(\beta{x})+\tilde{Q_k}(x)sin(\beta{x})),k=max(m,n) &\text{если}\space\alpha\mp{i\beta}\space\text{не корни }   \\\
   x^se^{\alpha{x}}(\tilde{P_k}(x)cos(\beta{x})+\tilde{Q_k}(x)sin(\beta{x})),k=max(m,n) &\text{если}\space\alpha\mp{i\beta}\space\text{корни }
\end{cases}$

**Теорема** Если $y_j(x)$ - решение уравнения $a_0(x)y^{(n)}+a_1(x)y^{(n-1)}+..+a_n(x)y=f_k(x), k=\overline{1,m}$, то функция $y(x)=\displaystyle\sum_{k=1}^{m}{y_k(x)}$ является решением уравнения $a_0(x)y^{(n)}+a_1(x)y^{(n-1)}+..+a_n(x)y=\displaystyle\sum_{k=1}^{m}{f_k(x)}$.

### Уравнение Эйлера.

Линейные уравнения вида $C_0x^ny^{(n)}+C_1x^{n-1}y^{(n-1)}+..+C_{n-1}xy\'+C_ny=0$ (4), $C_i-const, i=\overline{1,n}$ называют **уравнениями Эйлера**.

Заменой $x=e^t$ уравнение (4) преобразуется в линейное однородное уравнение

Если в уравнениии (4) вместо x буде выражение вида $ax+b$, то такое уравнение тоже называется Эйлеровым, и тогда делаем замену $ax+b=e^t$.',
            'examples' => '### Линейные однородные дифференциальные уравнения

1) Составить линейное однородное уравнение, если его характеристическое уравнение $2\lambda^2-3\lambda-5=0$.

$2y\'\'-3y\'-5y=0$

2) Составить линейное однородное дифференциальное уравнение если его ФСР$=\lbrace{1,e^{-x}\sin(x),e^{-x}\cos(x)}\rbrace$

Найдем корни соответствующего характеристического уравнения.

Для 1: $\lambda_1=0$.

Для $e^{-x}\sin(x)$: $\lambda_2=-1-i$

Для $e^{-x}\cos(x)$: $\lambda_3=-1+i$

Тогда характеристическое уравнение: $\lambda(\lambda+1+i)(\lambda+1-i)=0$ или $\lambda^3+2\lambda^2+2\lambda$

А дифференциальное уравнение: $y^{(3)}+2y\'\'+2y\'$

3) Проинтегрировать уравнение $y^{(4)}+4y^{(3)}+10y\'\'+12y\'+5y=0$

Составим характеристическое уравнение: $\lambda^4+4\lambda^3+10\lambda^2+12\lambda+5=0$

Его корни $\lambda_1=\lambda_2=-1,\space\lambda_3=-1+2i,\space\lambda_4=-1-2i$

Тогда общее решение дифференциального уравнения:

$(C_1+C_2x)e^{-x}+(C_3\cos(2x)+C_4\sin(2x))e^{-x}$.

4) Решить задачу Коши $y\'\'\'+y\'\'=0,\space{y(0)=1},\space{y\'(0)=0},\space{y\'\'(0)=1}$

Составим соответствующее характеристическое уравнение: $\lambda^3+\lambda^2=0$.

Его корни: $\lambda_1=\lambda_2=0,\space\lambda_3=-1$.

Тогда общее решение дифференциального уравнения: $y=C_1+C_2x+C_3e^{-x}$.

Найдем $y\', y\'\'$:

$y\'=C_2-C_3e^{-x}$
$y\'\'=C_3e^{-x}$

Найдем значения $C_1,C_2,C_3$, удовлетворяющие условиям задачи Коши, для этого решим систему:
->$\begin{cases}
	C_1+C_2*0+C_3*e^0=1 \\\
  C_2-C_3*e^0=0 \\\
  C_3*e^0=1
\end{cases}\space\begin{cases}
	C_1=0 \\\
  C_2=0 \\\
  C_3=1
\end{cases}$<-

Получили решение задачи Коши: $y=e^{-x}$

### Линейные неоднородные дифференциальные уравнения

1) Решить уравнение $y\'\'+4y\'+3y=9e^{-3x}$

Найдем общее решение соответствующего однородного уравнения $y\'\'+4y\'+3y=0$ (*), получим: $y_0=C_1e^{-x}+C_2e^{-3x}$

$x=-3$ является корнем характеристического уравнения, соответствующего однородному уравнению (*), поэтому частное решение имеет вид $y_1=axe^{-3x}$.

Тогда
$\begin{aligned}
   &y_1\'=ae^{-3x}-3axe^{-3x}\\\
   &y_1\'\'=-6ae^{-3x}+9axe^{-3x}
\end{aligned}$

Найдем параметр a, подставив частное решение $y_1$ и его производные в неоднородное уравнение:

$-2ae^{-3x}=9e^{-3x}$, тогда  $a=-4,5$

Таким образом частное решение $y_1=-4,5xe^{-3x}$

И общее решение неоднородного уравнения: $y=y_0+y_1=C_1e^{-x}+C_2e^{-3x}-4,5xe^{-3x}$

2) Решить уравнение $y\'\'-5y\'+6y=10(1-x)e^{-2x}$

Найдем общее решение соответствующего однородного уравнения $y\'\'-5y\'+6y=0$ (*), получим: $y_0=C_1e^{2x}+C_2e^{3x}$

$x=-2$ не является корнем характеристического уравнения, соответствующего однородному уравнению (*), частное решение имеет вид $y_1=(ax+b)e^{-2x}$.

Тогда
$\begin{aligned}
   &y_1\'=ae^{-2x}-2(ax+b)e^{-2x}\\\
   &y_1\'\'=-4ae^{-2x}+4(ax+b)e^{-2x}
\end{aligned}$

Найдем параметры a и b, подставив частное решение $y_1$ и его производные в неоднородное уравнени и приравняв коэффициенты одинаковых элементов:

$-9ae^{-2x}+20(ax+b)e^{-2x}=10(1-x)e^{-2x}$, тогда  
$\begin{cases}
	-9a+20b=10\\\
  20a=-10
\end{cases},\space\begin{cases}
	a=-\frac{1}{2}\\\
  b=\frac{11}{40}
\end{cases}$

Таким образом частное решение $y_1=(-\frac{1}{2}x+\frac{11}{40})e^{-2x}$

И общее решение неоднородного уравнения: $y=y_0+y_1=C_1e^{2x}+C_2e^{3x}+(-\frac{1}{2}x+\frac{11}{40})e^{-2x}$

3) Решить уравнение $y\'\'+2y\'+5y=e^{-x}\sin(2x)$

Найдем общее решение соответствующего однородного уравнения $y\'\'+2y\'+5y=0$ (*), получим: $y_0=e^{-x}(C_1\cos(2x)+C_2\sin(2x))$

$x=-1-2i$ является корнем характеристического уравнения, соответствующего однородному уравнению (*), поэтому частное решение имеет вид $y_1=xe^{-x}(a\sin(2x)+b\cos(2x))$.

Тогда
$\begin{aligned}
   &y_1\'=(e^{-x}-xe^{-x})(a\sin(2x)+b\cos(2x))+2xe^{-x}(a\cos(2x)-b\sin(2x))\\\
   &y_1\'\'=(-2e^{-x}-3xe^{-x})(a\sin(2x)+b\cos(2x))+4(e^{-x}-xe^{-x})(a\cos(2x)-b\sin(2x))
\end{aligned}$

Подставим частное решение $y_1$ и его производные в неоднородное уравнение и приведем подобные слагаемые.

$4e^{-x}(a\cos(2x)-b\sin(2x))=e^{-x}\sin(2x)$

Найдем коэффициенты $a,\space{b}$, приравняв коэффициенты при одинаковых элементах (т.е. $e^{-x}\sin(2x),\space{}e^{-x}\cos(2x)$) в правой левой частях последнего равенства:

$\begin{cases}
	4a=0\\\
  -4b=1
\end{cases}\space\begin{cases}a=0\\\b=-\frac{1}{4}\end{cases}$

Таким образом частное решение $y_1=-\frac{1}{4}xe^{-x}\cos(2x)$

И общее решение неоднородного уравнения: $y=y_0+y_1=e^{-x}(C_1\cos(2x)+C_2\sin(2x))-\frac{1}{4}xe^{-x}\cos(2x)$

4) Решить уравнение $y\'\'+4y\'+3y=9e^{-3x}+cos(x)$

Здесь воспользуемся принципом суперпозиции для нахождения частного решения: Если $y_1$ и $y_2$ - частные решения уравнений $L[x]=f_1(x)$ и $L[x]=f_2(x)$, то и $y_1+y_2$ частное решение уравнения $L[x]=f_1(x)+f_2(x)$.

Уравнение $y\'\'+4y\'+3y=9e^{-3x}$ мы уже решали первым в этом пункте и нашли частное решение $y_1=-4,5xe^{-3x}$.

Найдем частное решение для  $y\'\'+4y\'+3y=cos(x)$, оно имеет вид $y_2=a\cos(x)+b\sin(x)$ и его производные: 

$\begin{aligned}
   &y_1\'=-a\sin(x)+b\cos(x)\\\
   &y_1\'\'=-a\cos(x)-b\sin(x)
\end{aligned}$

Подставляем в неоднородное уравнение $y\'\'+4y\'+3y=cos(x)$, тогда

$2a\cos(x)+2b\sin(x)-4a\sin(x)+4b\cos(x)=cos(x)$

Решаем систему:

$\begin{cases}2a+4b=1\\\2b-4a=0\end{cases}\space{}\begin{cases}a=\frac{1}{10}\\\b=\frac{1}{5}\end{cases}$

Получаем $y_2=\frac{1}{10}\cos(x)+\frac{1}{5}\sin(x)$

Таким образом общее решение уравнения $y\'\'+4y\'+3y=9e^{-3x}+cos(x)$:

$y=y_0+y_1+y_2=C_1e^{-x}+C_2e^{-3x}-4,5xe^{-3x}+0,1\cos(x)+0,2\sin(x)$

### Уравнение Эйлера

1) Решить однородное уравнение Эйлера $x^2y\'\'+3xy\'+y=0$

Сделаем замену $x=e^t$ и составим характеристическое уравнение для уравнения Эйлера.

$\lambda(\lambda-1)+3\lambda+1=0$ или $(\lambda+1)^2=0$

Его корни: $\lambda_1=\lambda_2=-1$

И тогда общее решение: $y=(C_1+C_2t)e^{-t}$

Теперь возвратимся к $x$, тогда $y=(C_1+C_2ln|x|)\frac{1}{x}$

2) Решить неоднородное уравнение Эйлера $(x+1)^3y\'\'+3(x+1)^2y\'+(x+1)y=6ln(x+1)$

Поделим уравнение на $(x+1)$: $(x+1)^2y\'\'+3(x+1)y\'+y=\frac{6}{x+1}ln(x+1)$

Сделаем замену $(x+1)=e^t$ и составим характеристическое уравнение, для соответствующего однородного уравнения:

$\lambda(\lambda-1)+3\lambda+1=0$ или $(\lambda+1)^2=0$,

Тогда общее решение однородного уравнения $y_0=(C_1+C_2t)e^{-t}$

Восстановим по характеристиескому уравнению и правой части исходного уравнения новое неоднородное уравнение: $y\'\'+2y\'+y=6te^{-t}$

$x=-1$ - двухкратный корень характеристического уравнения и поэтому частное решение последнего неоднородного уравнения  имеет вид $y_1=t^2(at+b)e^{-t}$.

Найдем $y_1\',y_1\'\'$:

$\begin{aligned}
   &y_1\'=e^{-t}(-at^3+3at^2-bt^2+2bt)\\\
   &y_1\'\'=e^{-t}(at^3-6at^2+bt^2+6at-4bt+2b)
\end{aligned}$

Тогда: $e^{-t}(at^3-6at^2+bt^2+6at-4bt+2b+2(-at^3+3at^2-bt^2+2bt)+t^2(at+b))=6te^{-t}$

Решаем систему:

$\begin{cases}
  6a=6\\\
  2b=0
\end{cases}\space\begin{cases}a=1\\\b=0\end{cases}$

Тогда частное решение: $y_1=t^3e^{-t}$ 

Возвращаясь к $x$ имеем: $y_0=(C_1+C_2ln|x+1|)\frac{1}{x+1},\space{}y_1=\frac{1}{x+1}ln^3|x+1|$

И общее решение: $y=y_0+y_1=\frac{1}{x+1}(C_1+C_2ln|x+1|+ln^3|x+1|)$

### Метод вариации произвольной постоянной (метод Лагранжа)

1) Решить уравнение $y\'\'+2y\'+2y=\frac{1}{e^x\sin(x)}$

Найдем ФСР и общее решение соответствующего однородного уравнения: 
ФСР$\space=\lbrace{e^{-x}cos(x),\space{}e^{-x}sin(x)}\rbrace$
$y_0=e^{-x}(C_1cos(x)+C_2\sin(x))$.

Будем искать решения неоднородного уравнения в виде $y=e^{-x}(C_1(x)cos(x)+C_2(x)\sin(x))$

Для определения функций $C_1(x),C_2(x)$ решим систему:

$\begin{cases}
	C_1\'(x)e^{-x}cos(x)+C_2\'(x)e^{-x}sin(x)=0\\\
  C_1\'(x)e^{-x}(-cos(x)-sin(x))+C_2\'(x)e^{-x}(-sin(x)+cos(x))=\frac{1}{e^x\sin(x)}
\end{cases}\space\begin{cases}C_1\'(x)=-1\\\C_2\'(x)=\frac{cos(x)}{sin(x)}\end{cases}\space\begin{cases}C_1(x)=-x+C_1\\\C_2(x)=-\ln|\sin(x)|+C_2\end{cases},\space{}C_1,C_2-const$

Тогда общее решение неоднородного уравнения:

$y=e^{-x}((-x+C_1)cos(x)+(-\ln|\sin(x)|+C_2)\sin(x))$'
        ]);

        $questions = [
            [
                'q' => '',
                'a' => [
                    '',
                    '',
                    '',
                    '',
                ],
                'c' => [true, false, false, false]
            ],
        ];
        $this->create_questions($lesson, $questions);

        //Coding theory
        $course = Course::Create([
            'name' => 'Дискретная математика',
            'description' => 'Очень важный курс для настоящих героев!',
            'image' => 'diff_eq.jpeg',
            'category_id' => 1,
            'active' => true,
            'user_id' => 1
        ]);

        $names = ['Теория кодирования'];
        $blocks = [];

        foreach ($names as $k => $n) {
            $blocks[] = Block::Create([
                'course_id' => $course->id,
                'name' => $n,
                'active' => true,
                'sort' => $k
            ]);
        }

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Основные понятия и определения',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Пусть по двоичному симметричному каналу связи передаются сообщения. Передаваемую информацию необходимо закодировать, для обеспечения ее безопасности, при этом нужно затратить как можно меньше кодовых символов, а также уменьшить влияние помех и шумов в канале передачи, которые влекут повреждение сообщения, превращая его в другое сообщение.

Схема системы связи:
->$\boxed{\text{источник}}\to\boxed{\text{кодер}}\to\underset{\underset{\text{шум}}{\uparrow}}{\boxed{\text{канал}}}\to\boxed{\text{декодер}}\to\boxed{\text{получатель}}$<-

Будем рассматривать кода, состоящие из 0 и 1. Так, при передаче информации, 0 может превратиться в 1, а 1 в 0. Наша задача обнаружить и устранить такие ошибки.

Пусть $E^n$ - n-мерное метрическое пространство всех двоичных векторов длины n с метрикой Хэмминга.

$E^n=\lbrace{(v_1,..,v_n)|a_i\in\lbrace{0,1}\rbrace; 1\leq{i}\leq{n}}\rbrace$

Произвольное подмножество $C\subseteq{E^n}$ пространства $E^n$ называется **двоичным кодом** (блоковым кодом или просто кодом) длины n.

Элементы кода C называются **кодовыми словами**

**Хэммингово расстояние** d(x,y) между векторами $x,y\in{E^n}$ определяется как число координат в которых эти векторы различаются.

**Кодовое расстояние** d кода C равно минимальному расстоянию Хэмминга между различными кодовыми словами

**Вес Хэмминга** $w(x)$ вектора $x\in{E^n}$ равен числу ненулевых координат x, т.е. $w(x) = d(x,0^n)$

Вместо n сообщений будем передавать по каналу связи n кодовых слов, заранеее установив биекцию между сообщениями и кодовыми словами. Затем будем декодирвать кодовые слова, для получения правильных исходных сообщений.

Будем проводить декодирование по **максимуму правдоподобия**: переданным считается кодовое слово,  отличное от принятой последовательности в наименьшем числе координат.

Код, **обнаруживающий ошибки** по принятому слову, определяет где произошла ошибка.

Код, **исправляющий ошибки** по принятому слову, определяет какое слово было передано.

**Теорема.** Для того , чтобы код исправлял любые ошибки веса $w$, минимальное расстояние должно быть не меньше $2*w+1$. Для того чтобы код обнаруживал любые ошибки веса $w$, минимальное расстояние должно быть не меньше $w+1$.

*Доказательство*: Пусть d - минимальное расстояние кода C, s - сфера, радиус которой больше 0 и меньше $w+1$, а центр находится в кодовом слове v. Если $d\geq{w+1}$, то на s нет других кодовых слов. Если же $d\geq{2*w+1}$, то от точек s, расстояние до v меньше расстояния до других кодовых слов. ',
            'video' => 'defs.mp4'
        ]);

        $questions = [
            [
                'q' => 'Что такое хэммингово расстояние между векторами $x,y\in{E^n}$',
                'a' => [
                    'Число координат, в которых эти векторы различаются',
                    'Колличество различных линейных комбинаций этих векторов в $E^n$',
                    'Колличество нулевых координат суммы этих векторов',
                    'Число координат, в которых эти векторы не отличаются'
                ],
                'c' => [true, false, false, false]
            ],
            [
                'q' => 'Какое слово считается переданным, если следовать принципу максимума правдоподобия?',
                'a' => [
                    'Кодовое слово с минимальным весом',
                    'Содержащее наибольшее колличество нулей',
                    'Отличное от переданной последовательности в наименьшем числе компонент',
                    'Содержащее наибольшее колличество единиц'
                ],
                'c' => [false, false, true, false]
            ],
            [
                'q' => 'Что называется весом кодового слова?',
                'a' => [
                    'Его длина',
                    'Колличество его ненулевых компонент',
                    'Колличество его нулевых компонент'
                ],
                'c' => [false, true, false]
            ],
            [
                'q' => 'Число двоичных наборов длины n',
                'a' => [
                    'n',
                    '$n^2$',
                    '$n^n$',
                    '$2^n$'
                ],
                'c' => [false, false, false, true],
                'm' => 'На каждое из n мест можем поставить 0 или 1, по правилу произведения колличество таких комбинаций $\underbrace{2*..*2}_{\text{n раз}}=2^n$'
            ],
            [
                'q' => 'Число двоичных наборов длины n веса w',
                'a' => [
                    '$\binom{n}{w}$',
                    '$\frac{n}{w}$',
                    '$n*w$',
                    '$\log[w]{n}$'
                ],
                'c' => [true, false, false, false]
            ]
//            [
//                'q' => '',
//                'a' => [
//                    '',
//                    '',
//                    '',
//                    ''
//                ],
//                'c' => [false, false, false, false]
//            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Алфавитное кодирование.',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => '',
            'examples' => '1) С помощью алгоритма Фано построить код сообщения "AAABBABBBCCBCCDDEFAD"

Посчитаем вероятность встречи каждого символа в сообщении:

A - $\frac{5}{20}$, B - $\frac{6}{20}$, C - $\frac{4}{20}$, D - $\frac{3}{20}$, E - $\frac{2}{20}$

Запишем символы в таблицу, упорядочив их по убыванию вероятности встречи в сообщении,
далее делим символы на 2 группы

$\begin{array}{|c|c|c|c|c|}
   B & 6 & 0 & 0 &\\\
   A & 5 & 0 & 1 &\\\
   C & 4 & 1 & 0 & 0 \\\
   D & 3 & 1 & 0 & 1 \\\
   E & 1 & 1 & 1 & 0\\\
   F & 1 & 1 & 1 & 1
\end{array}$

2) С помощью алгоритма Хаффмена построить код сообщения "AAABBABBBCCBCCDDEFAD"

$\begin{array}{|c|c|c|c|c|c|c|}
   B & 6 & 6 & 6 & 9 & 11 & 10 \\\
   A & 5 & 5 & 5 & 6 & 9  & 11 \\\
   C & 4 & 4 & 5 & 5 &    & 01 \\\
   D & 3 & 3 & 4 &   &    & 000 \\\
   E & 1 & 2 &   &   &    & 001\\\
   F & 1 &   &   &   &    & 0001\\\
\end{array}$'
        ]);

        $questions = [
            [
                'q' => '',
                'a' => [
                    '',
                    '',
                    '',
                    ''
                ],
                'c' => [false, false, false, false]
            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Линейные коды',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => '**Линейным [n, k]-кодом** длины n называется подмножество пространства $E^n$, являющееся линейным подпространством размерности k в $E^n$.

Пусть в кодер поступило кодовое сообщение $u=(u_1..u_k)$. Сформируем кодовое слово $x=(x_1..x_n)=(u_1..u_kx_{k+1}..x_n)$, где первая часть слова $(x_1..x_k)=(u_1..u_k)$ равна исходному сообщению - информационные символы, а вторая часть слова $(x_{k+1}..x_n)$ : $Hx^t_i=0^{n-k}, i=\overline{k+1,n}$ - проверочные символы.

#### Способы задания линейного [n,k]-кода:
- Кодовая матрица порядка $2^k\times{n}$, строки которой все кодовые слова.
- Порождающая матрица G порядка $k\times{n}$, строки которой кодовые слова, образующие базис линейного кода.
- Проверочная $(n-k, n)$-матрица $H: \forall{x=(x_1..x_n)} Hx=Hx^t=o^{n-k}$(Задает n-k проверочных уравнений)

  **Теорема**. Минимальное кодовое расстояние линейного кода равно минимальному весу его ненулевого слова.
*Доказательство*: Для любых кодовых слов $x,y\in{C}$ число координат в которых они отличаются равно колличиству единиц в слове x+y, поэтому если расстояние между некоторыми x и y равно минимальному расстоянию, то оно равно весу слова $x+y\in{C}$. $\forall x,y\in{C}$ $x-y\in{C}$, поэтому  $d = \min\limits_{x\not={y}}(d(x,y))=\min\limits_{x\not={y}}(w(x-y))=\min\limits_{z\in{C}}(w(z))$

**Порождающая матрица G** - это матрица порядка $k\times{n}$, строками которой являются кодовые слова, образующие базис линейного кода.

**Проверочная матрица H** - это матрица порядка $n-k\times{n}$, такая что для любого кодового слова $x=(x_1..x_n)$ выполняется $Hx^t=0$.

**Теорема о связи проверочной и порождающей матриц.** Если проверочная матрица H линейного кода задана в канонической форме $H=[A_{n-k,k}|E_{n-k}]$, то порождающая матрица G этого кода имеет вид $G=[E_k,A_{n-k,k}]$.

*Доказательство:* Рассмотрим кодовое слово $x=(x_1..x_kx_{k+1}..x_n)$, в котором $(x_1..x_k)$ информационные символы, а остальные символы проверочные. $(x_1..x_k)^t = E_k(u_1..u_k)^t$.

Пусть $A=\begin{pmatrix}
   a_{1,1} & a_{1,2} & ... & a_{1,k} \\\
   : & : & .. & :\\\
   a_{n-k,1} & a_{n-k,2} & ... & a_{n-k,k}
\end{pmatrix}$

Тогда из определения проверочной матрицы $Hx^t=0$, т.е.  $a_{i,1}x_1+a_{i,2}x_2+...+a_{i,k}x_k+x_{k+i}=0 , i=\overline{1,n-k}$, 
откуда $x_{k+i}=-(a_{i,1}x_1+a_{i,2}x_2+...+a_{i,k}x_k)$

Таким образом $\begin{pmatrix}
   x_{k+1} \\\
   : \\\
   x_{n}
\end{pmatrix}=-A_{n-k,k}\begin{pmatrix}
   x_1 \\\
   :\\\
   x_k
\end{pmatrix}=-A_{n-k,k}\begin{pmatrix}
   u_1 \\\
   :\\\
   u_k
\end{pmatrix}$

Получаем $x^t=\begin{pmatrix}
   E_k \\\
   :\\\
   -A_{n-k,k}
\end{pmatrix}u^t$

Тогда $x=u(E_k|-A_{n-k,k}^t)=uG$

**Теорема о столбцах проверочной матрицы.** Код длины n имеет кодовое расстояние d тогда и только тогда, когда любые d-1 столбцов его проверочной матрицы H линейно независимы и найдутся d линейно зависимых столбцов.

*Доказательство:* 

Необходимость: Пусть x вектор веса w. Ясто что $x\in{C}\iff{Hx^t=0}$, что эквивалентно линейной зависимости некоторых w столбцов матрицы H. Обозначим $i$-й столбец матрицы H через $h_i$, т.e. $H=[h_1..h_n]$ Отсюда и из равенства $Hx^t=0$ получаем $\displaystyle\sum_{i=1}^n{h_ix_i}=0$, откуда следует соотношение $h_{i_1}+..+h_{i_w}=0$. Т.к. $d=\min\limits_{x\in{C}, x\not={0}}(w(x))$, получаем линейную зависимость некоторой совокупности d столбцов матрицы H.  

Достаточность очевидна.
',
            'examples' => '1) (5, 2)-код задан порождающей матрицей $G=\begin{pmatrix}
   1 & 0 & 0 & 1 & 0 \\\
   1 & 1 & 1 & 0 & 1
\end{pmatrix}$. Найти его проверочную матрицу H, множество кодовых слов C, кодовое расстояние d.

Составим всевозможные линейные комбинации порождающих векторов $g_1=(10010)$ $g_2=(11101)$ - строк матрицы G и получим множество кодовых слов C. $\forall{x\in{C}}\space{x=\alpha_1g_1+\alpha_2g_2}, \alpha_{1,2}\in{\lbrace0,1\rbrace}$, $\lvert{C}\rvert=2^2$

$C={\lbrace(00000),(10010),(11101),(01111)\rbrace}$

Минимальное кодовое расстояние $d=\min\limits_{x\in{C}}(w(x))=2$

В коде $C$ 4 кодовых слова, поэтому можно закодировать 4 сообщения.

Закодируем сообщение u=$(01)$

$u*G=(01)*\begin{pmatrix}
   1 & 0 & 0 & 1 & 0 \\\
   1 & 1 & 1 & 0 & 1
\end{pmatrix}=(01101)$

Найдем проверочную (2,5)-матрицу H, используя условие $H*G^t=0$

$(x_1x_2x_3x_4x_5)*\begin{pmatrix}
   1 & 1 \\\
   0 & 1 \\\
   0 & 1 \\\
   1 & 0 \\\
   0 & 1
\end{pmatrix}=0$

Решим систему линейных уравнений, с $5-2=3$ свободными переменными.
$\begin{cases}
   x_1+x_4=0  \\\
   x_1+x_2+x_3+x_5=0
\end{cases}\begin{cases}
   x_4=x_2+x_3+x_5  \\\
   x_1=x_2+x_3+x_5
\end{cases}$

$(x_2+x_3+x_5,x_2,x_3,x_2+x_3+x_5,x_5)=x_2(11010)+x_3(10110)+x_5(10011)$

$H=\begin{pmatrix}
   1 & 1 & 0 & 1 & 0 \\\
   1 & 0 & 1 & 1 & 0 \\\
   1 & 0 & 0 & 1 & 1
\end{pmatrix}$

2) Линейный (8,5)-код задан проверочной матрицей $H=\begin{pmatrix}
   1 & 1 & 1 & 1 & 0 & 0 & 1 & 1 \\\
   0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
   0 & 0 & 0 & 1 & 1 & 1 & 1 & 0
\end{pmatrix}$, найти порождающую матрицу $G$ и минимальное кодовое расстояние $d$

Будем искать $G$ из условия $HG^t=0$

$H=\begin{pmatrix}
   1 & 1 & 1 & 1 & 0 & 0 & 1 & 1 \\\
   0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
   0 & 0 & 0 & 1 & 1 & 1 & 1 & 0
\end{pmatrix}\begin{pmatrix}
   x_1 \\\
   x_2 \\\
   x_3 \\\
   x_4 \\\
   x_5 \\\
   x_6 \\\
   x_7 \\\
   x_8
\end{pmatrix}=0$

Решим СЛАУ c 8-5=3 свободными переменными:

$\begin{cases}
	x_1 + x_2 + x_3 + x_4 + x_7 + x_8 = 0 \\\
  x_2 + x_5 + x_6 + x_7 = 0 \\\
  x_4 + x_5 + x_6 + x_7 = 0
\end{cases}$

$(x_1,x_4+x_7+x_8,x_1,x_4,x_5,x_4+x_5+x_7,x_7,x_8)=x_1(10100000)+x_4(01010100)+x_5(00001100)+x_7(01000110)+x_8(01000001)$

$G=\begin{pmatrix}
   1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\
   0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\\
   0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\
   0 & 1 & 0 & 0 & 0 & 1 & 1 & 0 \\\
   0 & 1 & 0 & 0 & 0 & 0 & 0 & 1
\end{pmatrix}$

Видно, что $d=2$

'
            //'video' => ''
        ]);

        $questions = [
            [
                'q' => 'Какой код является линейным?',
                'a' => [
                    'Код, множество кодовых слов которого является подпространством в $E^n$.',
                    'Такой, что для любого кодового слова $(x_1..x_n)$ слово $(x_2..x_{n}x_1)$, также является кодовым.',
                    'Содержащий n линейно независимых кодовых слов.',
                    'Код, для которого минимальное расстояние Хэмминга равно 3'
                ],
                'c' => [true, false, false, false]
            ],
            [
                'q' => 'Если размерность порождающей матрицы линейного кода равна $2^k\times{n}$, то размерность его проверочной матрицы равна',
                'a' => [
                    '$2^{n-k}\times{n}$',
                    '$2^n\times{k}$',
                    '$n\times{2^k}$',
                    '$n\times{2^{n-k}}$'
                ],
                'c' => [true, false, false, false]
            ],
            [
                'q' => 'Свойства порождающей матрицы G линейного [n,k,d]-кода С',
                'a' => [
                    'Ее строками являются k линейно независимых векторов пространства $E^n$',
                    'Ее строками являются n линейно независимых векторов пространства $E^n$',
                    'Все кодовые слова кода С являются всевозможными линейными комбинациями ее строк',
                    'Матрица G порождает линейное пространство'
                ],
                'c' => [true, false, true, true]
            ],
            [
                'q' => 'Чему равно минимальное кодовое расстояние линейного [n,k]-кода С, если минимальный вес его ненулевого кодового слова равен w',
                'a' => [
                    '$\frac{2*w}{k}$',
                    '$\frac{2^w}{k}$',
                    '$\frac{n}{w}$',
                    '$w$'
                ],
                'c' => [false, false, false, true]
            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Коды Хэмминга',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Двоичным **(n, k)-кодом Хэмминга** является код, заданный проверочной матрицей H, столбцами которой являютя все ненулевые векторы длины $m=\log_2{n}$

Пример (7, 4)-кода Хэмминга:

$\begin{pmatrix}
   0 & 1 & 0 & 1 & 1 & 1 & 0 \\\
   0 & 1 & 1 & 1 & 0 & 0 & 1 \\\
   1 & 1 & 1 & 0 & 1 & 0 & 0
\end{pmatrix}$

Удобно записывать проверочную матрицу кода Хэмминга, располагая ее столбцы в натуральном порядке, т.е. i-й столбец равен двоичному представлению числа i.

Рассмотрим пример (7, 4)-кода Хэмминга, со столбцами расположенными в натуральном порядке.

$\begin{pmatrix}
   0 & 0 & 0 & 1 & 1 & 1 & 1 \\\
   0 & 1 & 1 & 0 & 0 & 1 & 1 \\\
   1 & 0 & 1 & 0 & 1 & 0 & 1
\end{pmatrix}$

Очевидно, что любые два столбца матрицы H линейно независимы и найдутся три линейно зависимых столбца, следовательно по теореме о столбцах проверочной матрицы кодовое расстояние равно 3 и значит код исправляет одну ошибку

Пусть столбцы проверочной матрицы H кода Хэмминга расположены в натуральном порядке. Тогда справедлива
**Теорема.** Если произошла ошибка в i-м символе, то синдром S равен двоичному предствлению числа i.
### Расширенный код Хэмминга.

Расширенный код Хэмминга получается из (n,k)-кода Хэмминга добавлением бита проверки на четность. Кодовое расстояние при этом увеличивается на 1. Таким образом расширенный код Хэмминга является (n+1,k)-кодом с минимальным расстоянием 4, исправляющим 1 и обнаруживающим 2 ошибки.

Проверочная матрица $H\'$ расширенного кода Хэмминга может быть получена из проверочной матрицы $H$ кода Хэмминга добавлением в конец столбца из нулей, а затем приписыванием в качестве первой строки строки из единиц.

$H\'=\begin{pmatrix}
	1 & 1 & 1 & .. & 1 \\\
  &&&& 0 \\\
  &&H&& 0 \\\
  &&&& : \\\
  &&&& 0
\end{pmatrix}$

Опишем схему декодирования расширенного $(8,3)$-кода Хэмминга $C\'$ длины 8.

$H\'=\begin{pmatrix}
	 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\\
   0 & 0 & 0 & 1 & 1 & 1 & 1 & 0\\\
   0 & 1 & 1 & 0 & 0 & 1 & 1 & 0\\\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0
\end{pmatrix}$

Пусть принят вектор $y\'=(y_1..y_8)$.
Параллельно рассмотрим код Хэмминга $C$ для принятого вектора $y=(y_1..y_7)$

Тогда $S_y=\begin{pmatrix}
  y_4+y_5+y_6+y_7 \\\
  y_2+y_3+y_6+y_7 \\\
  y_1+y_3+y_5+y_7
\end{pmatrix},\space{}S_{y\'}=\begin{pmatrix}
	y_1+..+y_8 \\\
  y_4+y_5+y_6+y_7 \\\
  y_2+y_3+y_6+y_7 \\\
  y_1+y_3+y_5+y_7
\end{pmatrix}=S_y=\begin{pmatrix}
	y_1+..+y_8 \\\
  S_y
\end{pmatrix}$

Пусть произошла ошибка в одной из первых семи позиций, например в 3-ей позиции, тогда $S_y=(011)$ 

Тогда $S_{y\'}=\begin{pmatrix}y_1+..+y_8\\\S_y\end{pmatrix}=\begin{pmatrix}1\\\S_y\end{pmatrix}$

Таким образом при виде синдрома $S_{y\'}=\begin{pmatrix}1\\\S_y\end{pmatrix}$ полученого вектора в расширенном коде Хэмминга имеем позицию ошибки равную двоичному представлению $S_y$

Если получаем $S_{y\'}=\begin{pmatrix}0\\\S_y\end{pmatrix}$, то в общем случае можно сказать что расширенный код Хэмминга может обнаружить 2 и более ошибок.',
            'examples' => '1) Определить положение ошибки в коде Хэмминга длины 7, если принят вектор $x=(1111000)$.

Т.к. $7=2^3-1$, то m=3 и имеем (7,3,3)-код Хэмминга.

Составим его поверочную матрицу ( ее столбцами являются все различные ненулевые векторы длины 3 ), расположив ее столбцы в натуральном порядке.

$H=\begin{pmatrix}
	0 & 0 & 0 & 1 & 1 & 1 & 1 \\\
  0 & 1 & 1 & 0 & 0 & 1 & 1 \\\
  1 & 0 & 1 & 0 & 1 & 0 & 1
\end{pmatrix}$

$x=(1111000),\space{S_x=}Hx^t=(100)^t$.

Значит ошибка произошла в 4 позиции и декодированное слово $\tilde{x}=(1110000)$ (Здесь мы просто находим представление $S_x$ в десятичной системе счисления, т.е. $100_2=4_{10}$, это справедливо за счет того что записывали столбцы матрицы $H$ в натуральном порядке)


2) Исправить или обнаружить ошибки в словах $x=(11010011)$ и $y=(11001111)$ расширенного кода Хэмминга длины 8.

Построим проверочную матрицу расширенного (8,3)-кода Хэмминга.

$H\'=\begin{pmatrix}
	 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\\
   0 & 0 & 0 & 1 & 1 & 1 & 1 & 0\\\
   0 & 1 & 1 & 0 & 0 & 1 & 1 & 0\\\
   1 & 0 & 1 & 0 & 1 & 0 & 1 & 0
\end{pmatrix}$

Далее найдем синдромы принятых векторов.

$S_x=H\'x=(1000)^t$, значит в x нет ошибок и $x\in{C}$

$S_y=H\'y=(0111)^t$, обнаруживаем в векторе $y$ имеется 2 или более ошибок.'
        ]);

        $questions = [
            [
                'q' => 'Сколько ошибок исправляет код Хэмминга длины 7?',
                'a' => [
                    '3',
                    '7',
                    '1',
                    '0'
                ],
                'c' => [false, false, true, false]
            ],
            [
                'q' => 'Минимальное расстояние кода Хэмминга равно',
                'a' => [
                    '4',
                    '3',
                    '2',
                    '1'
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Сколько столбцов в проверочной матрице расширенного кода Хемминга, полученного из $(7,4)$-кода Хэмминга',
                'a' => [
                    '7',
                    '8',
                    '6',
                    '9'
                ],
                'c' => [false, true, false, false]
            ],
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
        'block_id' => $blocks[0]->id,
        'active' => true,
        'name' => 'Декодирование линейных кодов.',
        'resources' => json_encode(['http:://hello.ru']),
        'sort' => 1,
        'text' => 'Пусть сообщение $u=(u_1..u_k)$ закодировано кодовым словом $x=(x_1..x_n)$, которое передается по каналу связи с шумом. Принятый вектор $y=(y_1..y_n)$ может отличаться от $x$.

Рассмотрим вектор ошибок e.

$e=y-x=(e_1..e_n), e_i=\begin{cases}
	0 \text{, с вероятностью}\space{1-p} \\\
  1 \text{, с вероятностью}\space{p}
\end{cases}$, $0<p<\frac{1}{2}$

Поскольку ошибки происходят независимо с вероятнстью $p$, то для e имеем:

->$p\lbrace{e=(000..0)}\rbrace=(1-p)^n$<-
->$p\lbrace{e=(010..0)}\rbrace=p(1-p)^{n-1}$<-
->...<-
->$p\lbrace{e=v, w(v)=k}\rbrace=p^k(1-p)^{n-k}$<-

Т.к. $p<\frac{1}{2}$, то $1-p>p$, и справедливо $(1-p)^n>p(1-p)^{n-1}>..>p^k(1-p)^{n-k}$

Декодирование проводим по максимуму правдоподобия, т.е. y декодируется в близжайшее x, так e выбираем наименьшего веса

Рассмотрим линейный $(n,k)$-код $C$

Для любого вектора a множество $a+C=\lbrace{a+x|x\in{C}}\rbrace$ называется **смежным классом.**

**Утверждение 1.** Каждый смежный класс содержит $2^k$ векторов.

*Доказательство*: $|a+C|=|\lbrace{a+x|x\in{C}}\rbrace|=|C|=2^k$

**Утверждение 2.** Два вектора $a, b$ принадлежат одному и тому же смежному классу тогда и только тогда, когда $a-b\in{C}$.

*Доказательство:* 
1) Пусть $a\in{d+C}$ и $b\in{d+C}$, тогда $a=d+x_1, x_1\in{C}$ и $b=d+x_2, x_2\in{C}$, но тогда $a-b=d+x_1-d-x_2=x_1-x_2\in{C}$

2) Пусть $a-b\in{C}$, тогда $a-b=x, x\in{C}$, так получим  $a+C=b+x+C=b+C$

**Теорема.** Любые два смежных класса либо не пересекаются, либо совпадают.

*Доказательство:* Рассмотрим смежные классы $a+C$ и $b+C$. Пусть $x\in{a+C}$ и $x\in{b+C}$, тогда $x=a+x_1=b+x_2,\space{x_1, x_2}\in{C}$, но тогда $a-b=x_2-x_1\in{C}$, значит по утверждению 2 $a$ и $b$, принадлежат одному и тому же смежному классу, то есть $a+C=b+C$.

$E^n=C\lor(a^1+C)\lor..\lor{(a^m+C)}$, где $m=2^{n-k}-1$

Таким образом постранство $E^n$ можно разобрать на классы эквивалентности по линейному коду $C$.

Принятый вектор $y$ попадает в некоторый класс эквивалентности с индексом $i$, т.е. $y=a^i+C$, что означает $y=a^i+x, x\in{C}$. Если было передано слово $x\'$, то вектор ошибок $e=y-x\'=a^i+x-x\'=a^i+x\'\'\in{a^i+C}$, то есть $e$ принадлежит тому же классу смежности, что и $y$. Так все возможнные вектора ошибок принадлежат тому же классу смежности, что и $y$.

Из смежного класса, содержащего $y$ выбирается вектор $e$ наименьшего веса. Затем декодируем $y$ как $x=y-e$

Вектор минимального веса из смежного класса, называется **лидером** этого смежного класса.

Процесс декодирования можно упростить с помощью **синдромов**. Для декодирования:
1) Выписываем лидеры смежных классов и сответствующие им синдромы.
2) Получив вектор $y$, вычисляем его синдром.
3) Ищем лидер $a^i$ смежного класса с с тем же синдромом, что и у вектора $y$.
4) $x=y-a^i$ - предположительно посланный вектор $x$.

### Свойства синдрома

Пусть $S_y$ - синдром вектора $y\in{E^n}$, C - линейный $(n,k)$-код

**Утверждение 3.** Если проверочная матрица имеет $n-k$ строк, то $S_y$ является вектором длины  $n-k$

**Утверждение 4.** $S_y=0\Leftrightarrow{y\in{C}}$.

**Утверждение 5.** $S_y=\sum{h_j},\space{h_j}\in{H}$, где $j$ пробегает все индексы столбцов проверочной матрицы $H$, в которых произошли ошибки. 

*Доказательство:* Пусть получен вектор $y=x+e,\space{x}\in{C}$, тогда используя утверждение 4 имеем $S_y=Hy^t=H(x+e)^t=Hx^t+He^t=He^t$

Пусть $e_{j_1}=..=e_{j_s}=1$, значит произошли ошибки в $j_1..j_s$ координатах, и тогда имеем:
$He^t=\displaystyle\sum_{k=1}^s{e_{j_k}h_{j_k}}=h_{j_1}+..+h_{j_s},\space{h_{j_k}}$ - $k$-й столбец $H$

Таким образом $S_y=\displaystyle\sum_{k=1}^s{h_{j_k}}$, то есть синдром вектора выделяет те позиции где произошли ошибки.',
        'examples' => '1) Построить таблицу синдромов и соответствующих лидеров для $(8,3)$-кода, с порждающей матрицей $G=\begin{pmatrix}
	1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\\
  0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
  1 & 0 & 0 & 1 & 1 & 0 & 1 & 1
\end{pmatrix}$. Исправить ошибки в словах $x=(11110110)$ $y=(10010111)$ $z=(01111100)$.

Решение:

Приведем матрицу $G$ к каноническому виду $[E_3|A]$, тогда $H=[A^t|E_5]$.

$G=\begin{pmatrix}
	1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\\
  0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
  1 & 0 & 0 & 1 & 1 & 0 & 1 & 1
\end{pmatrix}\backsim\begin{pmatrix}
	1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\\
  0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
  0 & 0 & 1 & 0 & 1 & 1 & 0 & 0
\end{pmatrix}\backsim\begin{pmatrix}
	1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 \\\
  0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 \\\
  0 & 0 & 1 & 0 & 1 & 1 & 0 & 0
\end{pmatrix}=G\'$

$H=\begin{pmatrix}
	1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\
  1 & 1 & 1 & 0 & 1 & 0 & 0 & 0 \\\
  0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\\
  1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\
  1 & 1 & 0 & 0 & 0 & 0 & 0 & 1
\end{pmatrix}$

Составим таблицу всевозможных сообщений и кодовых слов для исходного кода C с порождающей матрицей G и кода C\', с порождающей матрицей канонического вида G\'

$\begin{array}{|c|c|c|c|c|c|c|c|c|}
   F^3_2 & 000 & 001 & 010 & 011 & 100 & 101 & 110 & 111\\\
   C & 00000000 & 10011011 & 01001101 & 11010110 & 10110111 & 00101100 & 11111010 & 01100001 \\\
   C\' & 00000000 & 00101100 & 01001101 & 01100001 & 10011011 & 10110111 & 11010110 & 11111010
\end{array}$

Свойство проверочной матрицы $GH^t=0$ говорит о том, что проверочная матрица, будучи порождающей для дуального кода, имеет строки, ортогональные всем кодовым словам, поэтому приведение $G$ к систематическому виду $G\'$ этого свойства не нарушает.

Колличество синдромв для кода C равно $\frac{2^n}{|C|}=\frac{2^n}{2^k}=2^{n-k}=2^m=2^5=32$

Запишем таблицу синдромов $S_{e_i}$ и соответствующих им лидеров $e_i$ (Для сокращения записи будем записывать синдромы в транспонированном виде)

$\begin{array}{c|c|c|c|c|c|c|c|c|c|c|c|}
   i & e_i & S^t_{e_i} & i & e_i & S^t_{e_i} & i & e_i & S^t_{e_i} & i & e_i & S^t_{e_i}\\\
   1 & 00000000 & 00000 &  9 & 00001000 & 01000 & 17 & 00010000 & 10000 & 25 & 00011000 & 11000 \\\
   2 & 00000001 & 00001 & 10 & 00001001 & 01001 & 18 & 00010001 & 10001 & 26 & 10000010 & 11001 \\\
   3 & 00000010 & 00010 & 11 & 00001010 & 01010 & 19 & 00010010 & 10010 & 27 & 10000001 & 11010 \\\
   4 & 00000011 & 00011 & 12 & 10100000 & 01011 & 20 & 10001000 & 10011 & 28 & 10000000 & 11011 \\\
   5 & 00000100 & 00100 & 13 & 00001100 & 01100 & 21 & 00010100 & 10100 & 29 & 00110000 & 11100 \\\
   6 & 00000101 & 00101 & 14 & 01000000 & 01101 & 22 & 01001000 & 10101 & 30 & 01010000 & 11101 \\\
   7 & 00000110 & 00110 & 15 & 00100010 & 01110 & 23 & 11000000 & 10110 & 31 & 10101000& 11110 \\\
   8 & 00000111 & 00111 & 16 & 01000010 & 01111 & 24 & 10100000 & 10111 & 32 & 10000100 & 11111 \\\
\end{array}$

Теперь найдем синдромы полученных слов. Затем для исправления ошибок ищем в таблице синдромов и лидеров соответствующего лидера и принимаем его за вектор ошибок. Получим $\tilde{x}$ - декодированное слово и $u_x$ - соответствующее сообщение из таблицы кодовых слов и сообщений (но нужно искать сообщения, соответствующие исходному коду C)

a) $x=(11110110),\space{S_x}=Hx^t=(01100)^t,\space{e_x}=(00001100),\space\tilde{x}=x-e_x=(11111010),\space{u_x=(110)}$ 

b) $y=(10010111),\space{S_y}=(01100)^t,\space{e_y}=(00001100),\space\tilde{y}=y-e_y=(10011011),\space{u_y=(001)}$

c) $z=(011111100),\space{S_z}=(11101)^t,\space{e_z}=(01010000),\space\tilde{z}=z-e_z=(00101100),\space{u_z=(101)}$
'
    ]);

        $questions = [
            [
                'q' => 'Сколько единиц будет в вектое ошибок, если при передаче произошла 1 ошибка',
                'a' => [
                    'Все зависит от переданного кодового слова.',
                    '0',
                    '1',
                    'Число, равное минимальному весу принятого вектора.',
                    'Число, равное минимальному весу переданного вектора.',
                ],
                'c' => [false, false, true, false, false]
            ],
            [
                'q' => 'По каналу связи передано кодовое слово $x$. Если синдром принятого вектора $y$ равен нулевому вектору, то',
                'a' => [
                    '$y$ - нулевой вектор',
                    'вектор ошибок $e=y-x$ - нулевой вектор',
                    'все координаты вектора ошибок $e=y-x$ единицы',
                    'При передаче не поизошло ошибок',
                    'При передаче произошли ошибки',
                    '$y$ и $e=x-y$ не лежат в одном классе смежности'
                ],
                'c' => [false, true, false, true, false, false]
            ],
            [
                'q' => 'Для реализации принципа максимума правдоподобия при декодировании',
                'a' => [
                    'В качестве принятого выбирается вектор с минимальным весом',
                    'В качестве принятого выбирается вектор с максимальным весом',
                    'Выбирается вектор ошибок с минимальным весом',
                    'Выбирается вектор ошибок с максимальным весом'
                ],
                'c' => [false, false, true, false]
            ],
            [
                'q' => 'Если синдромы двух принятых векторов $u$ и $v$ равны, то можно утверждать что',
                'a' => [
                    'Ошибки произошли в одинаковых позициях',
                    'Эти векора неотличимы',
                    'Вектора ошибок этих векторов равны',
                    '$u$ и $v$ декодируются в одно и то же кодовое слово',
                    'Исходное слово для $u$ и $v$ было одним и тем же',
                    '$u$ и $v$ попадают в один и тот же смежный класс'
                ],
                'c' => [true, false, true, false, false, true]
            ],
            [
                'q' => 'Найдите длину $S_y$, если в проверочной матрице $n-k$ строк',
                'a' => [
                    '$n$',
                    '$k$',
                    '$n-k$',
                    '$n^k$'
                ],
                'c' => [false, false, true, false]
            ]
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Коды Рида-Маллера.',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Двоичный код Рида-Маллера $RM(r,m)$ порядка $r$ и длины $2^m$ определяется как множество всех векторов $f$, задаваемых булевыми функциями $f(x_1,..,x_m)$,  представимыми всеми полиномами Жегалкина, степень которых не превосходит r.

В качестве примера рассмотрим $RM(1,8)$. Число переменных $m=\log_28=3$. Так RM(1,8) состоит из всех векторов, задаваемых булевыми функциями от 3-ёх переменных.

Запишем общий вид полинома Жегалкина от трех переменных:

$a_{000}+a_{001}x_1+a_{010}x_2+a_{011}x_1x_2+a_{100}x_3+a_{101}x_1x_3+a_{110}x_2x_3+a_{111}x_1x_2x_3$

Опишем все векторы кода $RM(1,8)$ и соответствующие полиномы Жегалкина:

->$\begin{array}{c|c}
   \text{полином} & \text{кодовое слово} \\\
   0   & 00000000 \\\
   x_3 & 00001111 \\\
   x_2 & 00110011 \\\
   x_1 & 01010101 \\\
   x_3+x_2 & 00111100 \\\
   x_3+x_1 & 01011010 \\\
   x_2+x_1 & 01100110 \\\
   x_3+x_2+x_1 & 01101001 \\\
   1 & 11111111 \\\
   1+x_3 & 11110000 \\\
   1+x_2 & 11001100 \\\
   1+x_1 & 10101010 \\\
   1+x_3+x_2 & 11000011 \\\
   1+x_3+x_1 & 10100101 \\\
   1+x_2+x_1 & 10011001 \\\
   1+x_3+x_2+x_1 & 10010110 \\\
\end{array}$<-

**Теорема.** Наибольшее число ненулевых членов в полиноме Жегалкина от $m$ переменных степени $r$ равно $1+\binom{m}{1}+..+\binom{m}{r}$

*Доказательство:* Слагаемых, не содержащих переменных одно - это единица. Слагаемых, содержащих 1 переменную $\binom{m}{1}$. Слагаемых, содержащих $t$ переменных $\binom{m}{t}$. Таким образом, по правилу суммы, получаем нужное.

Значит размерность кода $RM(r,m)$ равна $1+\binom{m}{1}+..+\binom{m}{r}$ и код содержит $2^{1+\binom{m}{1}+..+\binom{m}{r}}$ кодовых слов.
'
        ]);

        $questions = [
            [
                'q' => 'Найдите минимальное расстояние кода $RM(3,8)$',
                'a' => [
                    '16',
                    '32',
                    '64',
                    '8'
                ],
                'c' => [false, true, true, false]
            ],
            [
                'q' => 'Какое наибольшее колличество ненулевых переменных может содержать полином Жегалкина от 8 переменных степени 3?',
                'a' => [
                    '32',
                    '64',
                    '103',
                    '93'
                ],
                'c' => [false, false, false, true]
            ],
            [
                'q' => 'Найдите длину $RM(3,8)$',
                'a' => [
                    '8',
                    '128',
                    '516',
                    '256'
                ],
                'c' => [false, false, true, false]
            ]
        ];
        $this->create_questions($lesson, $questions);

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Мажоритарное декодирование.',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => 'Множество проверочных уравнений называется **ортогональным** относительно $i$-й координаты, если переменная $x_i$ входит во все уравнения, а другие переменные входят не более чем в одно уравнение.

**Теорема.** Если для любого символа линейного кода существует не менее $d-1$ проверочных сумм, ортогональных относительно этого символа, то код имеет минимальное кодовое расстояние не меньшее, чем d.

Рассмотрим пример для линейного (7,3)-кода.

$H=\begin{pmatrix}
	1 & 1 & 0 & 1 & 0 & 0 & 0 \\\
  0 & 1 & 1 & 0 & 1 & 0 & 0 \\\
  0 & 0 & 1 & 1 & 0 & 1 & 0 \\\
  0 & 0 & 0 & 1 & 0 & 0 & 1
\end{pmatrix}$

Пусть принято кодовое слово $x=(x_1..x_7)$, тогда первой строке матрицы $H$ соответствует проверочное соотношение $x_1+x_2+x_4=0$, сумме $1, 2, 4$ строк $x_1+x_3+x_7=0$, сумме $1,2,3$ строк $x_1+x_5+x_6=0$.

Эти соотношения ортогональны относительно $x_1$

Теперь будем следовать следующему правилу: Если среди значений $x_1..x_7$ большинство составляют нули, то полагаем что $x_1=0$, иначе $x_1=1$. Это гарантирует верное решение, в случае если принятое слово содержит не более одной ошибки. Если колличество нулей равно колличеству единиц, это возможно в случае двойной ошибки, тогда сможем только обнаружить ошибки.

Если на первом шаге удается восстановить символы принятого слова, то код, для которого это возможно, называется **полностью ортогональным**

Если же на первом шаге восстанавливаются лишь некоторые комбинации из $t$ элементов принятого слова, далее комбинации из менее чем $t$ элементов и так далее до тех пор пока не будет получено множество проверочных сумм, ортогональных относительно некоторого ошибочного символа.',
            'examples' => '1) Проведем мажоритарное декодирование линейного $(8, 4)$-кода с порождающей матрицей G.

->$G=\begin{pmatrix}
	1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\
  0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\
 	0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\
  0 & 1 & 0 & 1 & 0 & 1 & 0 & 1
\end{pmatrix}=\begin{pmatrix}g_0\\\g_1\\\g_2\\\g_3\end{pmatrix}$<-

Пусть $x=(a_0..a_7)$ - произвольное кодовое слово. Его можно представить в виде линейной комбинации строк матрицы $G$: $x=x_0g_0+x_1g_1+x_2g_2+x_3g_3$ или 

$x=x_0\begin{pmatrix}1\\\1\\\1\\\1\\\1\\\1\\\1\\\1\end{pmatrix}+x_1\begin{pmatrix}0\\\0\\\0\\\0\\\1\\\1\\\1\\\1\end{pmatrix}+x_2\begin{pmatrix}0\\\0\\\1\\\1\\\0\\\0\\\1\\\1\end{pmatrix}+x_3\begin{pmatrix}0\\\1\\\0\\\1\\\0\\\1\\\0\\\1\end{pmatrix}=\begin{pmatrix}
	x_0 \\\
  x_0+x_3 \\\
  x_0+x_2 \\\
  x_0+x_2+x_3 \\\
  x_0+x_1 \\\
  x_0+x_1+x_3 \\\
  x_0+x_1+x_2 \\\
  x_0+x_1+x_2+x_3
\end{pmatrix}$

Найдем проверки для $x_3$
Видим что $a_0+a_1=x_3$ (Cумма первой и второй координаты вектора $x$).
Аналогично: $a_2+a_3=x_3,\space{}a_4+a_5=x_3\space{}a_6+a_7=x_3$

Проверки для $x_2$: $a_0+a_2=x_2,\space{}a_1+a_3=x_2,\space{}a_4+a_6=x_2,\space{}a_5+a_7=x_2$

Проверки для $x_1$: $a_0+a_4=x_1,\space{}a_1+a_5=x_1,\space{}a_2+a_6=x_1,\space{}a_3+a_7=x_1$

Далее, применяя к полученным проверкам принцип большинства, найдем значения коэффициентов $x_1,x_2,x_3$

Если определить $x_1,x_2,x_3$, то ожно найти и $x_0$. Рассмотрим равенство $x\'=x-x_1g_1-x_2g_2-x_3g_3$. При безошибочной передаче $x\'=x_0g_0$, то есть у $x\'$ все координаты должны быть одинаковыми. Значит все они равны либо 1 либо. По большинству принимаем значение $x_0$.

Пусть принято слово $(01110110)$, тогда

->$\begin{matrix}
   x_1=0 & x_2=1 & x_3=1\\\
   x_1=0 & x_2=0 & x_3=0\\\
   x_1=0 & x_2=1 & x_3=1 \\\
   x_1=1 & x_2=1 & x_3=1
\end{matrix}$<-

По большинству значений находим $x_1=0,\space{}x_2=1,\space{}x_3=1$, тогда $x\'=(00010000)$ следовательно $x_0=0$, $x=g_2+g_3=(01100110)$
Рассмотрим мажоритарное декодирование кода Рида-Маллера второго порядка $RM(2,4)$

Составим порождающую матрицу:

$G=\begin{pmatrix}
1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1 \\\
0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1 \\\
0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1 \\\
0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1 \\\
0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1 \\\
0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&1 \\\
0&0&0&0&0&0&0&0&0&0&1&1&0&0&1&1 \\\
0&0&0&0&0&0&0&0&0&1&0&1&0&1&0&1 \\\
0&0&0&0&0&0&1&1&0&0&0&0&0&0&1&1 \\\
0&0&0&0&0&1&0&1&0&0&0&0&0&1&0&1 \\\
0&0&0&1&0&0&0&1&0&0&0&1&0&0&0&1 \\\
\end{pmatrix}=\begin{pmatrix}g_0\\\g_1\\\g_2\\\g_3\\\g_4\\\g_1g_2\\\g_1g_3\\\g_1g_4\\\g_2g_3\\\g_2g_4\\\g_3g_4\end{pmatrix}$

Если $x$ - кодовое слово, то $x=a_0g_0+a_1g_1+a_2g_2+a_3g_3+a_4g_4+a_{12}g_1g_2+a_{13}g_1g_3+a_{14}g_1g_4+a_{23}g_2g_3+a_{24}g_2g_4+a_{34}g_3g_4$

Сначала определим правильные значения для коэффициентов $a_{ij}$, для кажого из которых имеется по 4 проверочных соотношения. Например для $a_{34}$ имеем:

->$\begin{matrix}a_{34}=x_0+x_1+x_2+x_3\\\a_{34}=x_4+x_5+x_6+x_7\\\a_{34}=x_8+x_9+x_{10}+x_{11}\\\a_{34}=x_{12}+x_{13}+x_{14}+x_{15}\end{matrix}$<-

После определения этих коэффициентов находим вектор $x\'=x-a_{12}g_1g_2-..-a_{34}g_3g_4$. Поскольку при безошибочной передаче $x\'=a_0g_0+a_1g_1+a_2g_2+a_3g_3+a_4g_4$, то проверочные соотношения для коэффициентов $a_1,a_2,a_3,a_4$ получаем из элементов вектора $x\'$ с помощью матрицы $G$. Например $a_4=x_0\'+x_1\'$ одно из проверочных соотношений для $a_4$, где $x_i\'$ - элементы вектора $x\'$.

И на третьем шаге определяем коэффициент $a_0$
'
        ]);

        $questions = [
            [
                'q' => 'Как называется множество проверочных уравнений относилельно $i$-й координаты, если переменная $x_i$ входит во все уравнения, а другие переменные входят не более чем в одно уравнение?',
                'a' => [
                    'Изометрическое',
                    'Ортогональное',
                    'Параллельное',
                    'Симметрическое'
                ],
                'c' => [false, true, false, false]
            ],
            [
                'q' => 'Какое самое малое кодовое расстояние может быть у кода, в котором для любого символа существует не менее $d-1$ проверочная сумма?',
                'a' => [
                    '$d-1$',
                    '$d+1$',
                    '$d$',
                    '$2*d$'
                ],
                'c' => [false, false, true, false]
            ],
            [
                'q' => 'Ортогональны ли суммы $a_0+a_1+a_2, a_0+a_2+a_3, a_0+a_3+a_4$',
                'a' => [
                    'Да',
                    'Нет',
                    'Невозможно определить'
                ],
                'c' => [false, true, true]
            ],
            [
                'q' => 'Ортогональны ли суммы $a_0+a_1+a_2, a_0+a_3+a_4, a_0+a_a_5+a_6$',
                'a' => [
                    'Да',
                    'Нет',
                    'Невозможно определить'
                ],
                'c' => [true, false, false]
            ]
        ];
        $this->create_questions($lesson, $questions);

        //OS
        $course = Course::Create([
            'name' => 'Операционные системы',
            'description' => 'Очень важный курс для настоящих героев!',
            'image' => 'diff_eq.jpeg',
            'category_id' => 1,
            'active' => true,
            'user_id' => 1
        ]);

        $names = ['Операционная система'];
        $blocks = [];

        foreach ($names as $k => $n) {
            $blocks[] = Block::Create([
                'course_id' => $course->id,
                'name' => $n,
                'active' => true,
                'sort' => $k
            ]);
        }

        $lesson = Lesson::Create([
            'block_id' => $blocks[0]->id,
            'active' => true,
            'name' => 'Задачи операционной системы.',
            'resources' => json_encode(['http:://hello.ru']),
            'sort' => 1,
            'text' => '**Операционная система** составляет основу программного обеспечения ПК. Операционная система представляет комплекс системных и служебных программных средств, который обеспечивает взаимодействие пользователя с компьютером и выполнение всех других программ.

С одной стороны, она опирается на базовое программное обеспечение ПК, входящее в его систему BIOS, с другой стороны, она сама является опорой для программного обеспечения более высоких уровней – прикладных и большинства служебных приложений.

Для того чтобы компьютер мог работать, на его жестком диске должна быть установлена (записана) операционная система. При включении компьютера она считывается с дисковой памяти и размещается в ОЗУ. Этот процесс называется загрузкой операционной системы.

Операционные системы различаются особенностями реализации алгоритмов управления ресурсами компьютера, областями использования.

1) количеству одновременно работающих пользователей: однопользовательские, многопользовательские;
+ **Однопользовательские** могут обслуживать только одного пользователя в один момент времени
+ **Многопользовательские** поддерживают одновременную работу на ЭВМ нескольких пользователей за различными терминалами, отличаются наличием средств защиты информации каждого пользователя от несанкционированного доступа других пользователей
2) числу процессов, одновременно выполняемых под управлением системы: однозадачные, многозадачные;
+ **Однозадачные** выполняют функцию предоставления пользователю виртуальной машины, делая более простым и удобным процесс взаимодействия пользователя с компьютером. Однозадачные ОС включают средства управления периферийными устройствами, средства управления файлами, средства общения с пользователем.
+ **Многозадачные** в дополнение ко всем функциям однозадачных ОС, они также управляют разделением совместно используемых ресурсов, таких как процессор, оперативная память, файлы и внешние устройства.
3) количеству поддерживаемых процессоров: однопроцессорные, многопроцессорные;
+ **Однопроцессорные** поддерживают режим распределения ресурсов только одного процессора
+ **Многопроцессорные** поддерживают режим распределения ресурсов нескольких процессоров для решения той или иной задачи
4) разрядности кода ОС: 8-разрядные, 16-разрядные, 32-разрядные, 64-разрядные;
5) типу интерфейса: командные (текстовые) и объектно-ориентированные (графические);
+ **Командные** с командным интерфейсом
+ **Графические** с графическим интерфейсом
6) типу доступа пользователя к ЭВМ: с пакетной обработкой, с разделением времени, реального времени;
+ **Пакетной обработки** в которых из программ, подлежащих выполнению, формируется пакет (набор) заданий, вводимых в ЭВМ и выполняемых в порядке очередности с возможным учетом приоритетности;
+ **Разделения времени** обеспечивающих одновременный диалоговый (интерактивный) режим доступа к ЭВМ нескольких пользователей на разных терминалах, которым по очереди выделяются ресурсы машины, что координируется операционной системой в соответствии с заданной дисциплиной обслуживания;
+ **Реального времени** обеспечивающих определенное гарантированное время ответа машины на запрос пользователя с управлением им какими-либо внешними но отношению к ЭВМ событиями, процессами или объектами.
7) типу использования ресурсов: сетевые, локальные.
+ **Сетевые** предназначены для управления ресурсами компьютеров, объединенных в сеть с целью совместного использования данных, и предоставляют мощные средства разграничения доступа к данным в рамках обеспечения их целостности и сохранности, а также множество сервисных возможностей по использованию сетевых ресурсов.
+ **Локальные** могут использоваться на любом персональном компьютере, а также на отдельном компьютере, подключенном к сети в качестве рабочей станции или клиента.
',
            'video' => 'defs.mp4'
        ]);

        $questions = [
            [
                'q' => 'Какая система составлят основу программного обеспечения персонального компьютера?',
                't' => 'task',
                'a' => 'операционная'
            ],
            [
                'q' => 'Как называется процесс считывания операционной системы с дисковой памяти и ее размещения на жестком диске?',
                't' => 'task',
                'a' => 'загрузка'
            ],
            [
                'q' => 'Какие OS предназначены для управления ресурсами ПК, включенными в сеть',
                't' => 'task',
                'a' => 'сетевые'
            ],
            [
                'q' => 'Какие OS гарантируют время ответа машины на запрос пользователя?',
                't' => 'task',
                'a' => 'реального времени'
            ],
            [
                'q' => 'Какая программа обеспечивает возможность работы пользователя с консольной операционной системой?',
                't' => 'task',
                'a' => 'терминал'
            ],
            [
                'q' => 'Какие категории присутствуют в классификации операционных систем в зависимости от типа системы?',
                'a' => [
                    'Процессорной обработки',
                    'Пакетной обработки',
                    'Реального времени',
                    'Многозадачные',
                    'Сетевые',
                    'Процедурной обработки',
                    'Функциональной обработки',
                    'Разделения времени'
                ],
                'c' => [false, true, true, false, false, false, false, true]
            ]
        ];
        $this->create_questions($lesson, $questions);
    }

    private function create_questions($lesson, $questions)
    {
        foreach ($questions as $i => $q) {
            $qc = $lesson->questions()->create([
                'text' => $q['q'],
                'type' => array_has($q, 't') ? $q['t'] : 'test',
                'answer' => array_has($q, 't') && $q['t'] === 'task' ? $q['a'] : json_encode(array_map(function ($a, $c) {
                    return [
                        'text' => $a,
                        'correct' => $c
                    ];
                }, $q['a'], $q['c'])),
                'points' => 5,
                'sort' => $i,
                'active' => true,
                'lesson_id' => $lesson->id
            ]);
            if (array_has($q, 'm')) {
                $qc->comment = $q['m'];
                $qc->save();
            }
        }
    }
}
